{"version":3,"file":"bundle.js","mappings":";;;;;;;;AAAA;AACA,IAAI,KAA4D;AAChE,IAAI,CACgH;AACpH,CAAC,6BAA6B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,4CAA4C;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB,sCAAsC,kBAAkB;AACvF,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA,wCAAwC;AACxC,yCAAyC;AACzC,4CAA4C;AAC5C,4CAA4C;AAC5C,oCAAoC;AACpC,iDAAiD;AACjD,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E;AACA;AACA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY;AACZ;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb,wCAAwC;AACxC;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2BAA2B;AAC/D;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mDAAmD,aAAa;;AAEhE,CAAC;AACD;;;;;;;;;;;;;;;;;;;;;ACpyDsD;AACH;AACA;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6CAA6C;AAC1D,gBAAgB,oDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,MAAM;AACtB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4CAA4C;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,2BAA2B,yDAAa;AACxC;AACA,QAAQ,8BAA8B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAe;AACpC;AACA;AACA,YAAY,qDAAqD;AACjE,YAAY,wBAAwB;AACpC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gEAAgB;AAC5B;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,wBAAwB;AACxB;AACA,GAAG,SAAS;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4BAA4B;AAC5B,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA,sBAAsB;AACtB;AACA;AACA,8BAA8B;AAC9B;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,QAAQ;AACR,6BAA6B;AAC7B;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,OAAO;AACP,QAAQ;AACR;AACA,GAAG;AACH;AACA;AAME;;;;;;;;;;;;;;;;;;AC9VF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc,SAAS,GAAG,qBAAqB,OAAO,uBAAuB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,6BAA6B,OAAO;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,6BAA6B,OAAO;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa;AACjE;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE,SAAS;AACT,OAAO;AACP;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,GAAG;AACpD;AACA;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,IAAI;AACJ;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,IAAI;AACJ;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,OAAO;AAC1E;AACA,iDAAiD,gBAAgB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mBAAmB;AAC3E;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D,uDAAuD,SAAS;AAChE;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,6BAA6B,oBAAoB;AACjD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,GAAG;AACH;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACiE;;;;;;;;;;;;;;;;AC/UjE;AACA,0CAA0C;AAC1C,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,eAAe,cAAc,SAAS,kBAAkB,IAAI;AAC5D,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AAIE;;;;;;;;;;;;;;;;;;AC1CyC;AACgB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA,uBAAuB,wDAAe;AACtC,UAAU,4DAAgB;AAC1B,UAAU,sDAAU,GAAG,sCAAsC;AAC7D,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AAC8C;;;;;;;SCvE9C;SACA;;SAEA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;SACA;;SAEA;SACA;;SAEA;SACA;SACA;;;;;UCtBA;UACA;UACA;UACA;UACA,yCAAyC,wCAAwC;UACjF;UACA;UACA;;;;;UCPA;;;;;UCAA;UACA;UACA;UACA,uDAAuD,iBAAiB;UACxE;UACA,gDAAgD,aAAa;UAC7D;;;;;;;;;;;;;;;ACN2C;AAC3C;AAC2D;AAC3D;AAKmB;AACnB;AACmD;AACnD;AACA;AACA,2DAAiB;AACjB;AACA;AACA,QAAQ,2DAAiB;AACzB,QAAQ,4DAAgB;AACxB,EAAE,8DAAoB;AACtB,0BAA0B,gEAAgB;AAC1C;AACA;AACA,uBAAuB,wDAAe;AACtC,UAAU,sDAAU,GAAG,sCAAsC;AAC7D;AACA;AACA;AACA","sources":["webpack://simple-emote-extension/./node_modules/mutation-summary/dist/umd/mutation-summary.js","webpack://simple-emote-extension/./dom2.js","webpack://simple-emote-extension/./emotes.js","webpack://simple-emote-extension/./lib.js","webpack://simple-emote-extension/./navigation.js","webpack://simple-emote-extension/webpack/bootstrap","webpack://simple-emote-extension/webpack/runtime/define property getters","webpack://simple-emote-extension/webpack/runtime/hasOwnProperty shorthand","webpack://simple-emote-extension/webpack/runtime/make namespace object","webpack://simple-emote-extension/./main.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.MutationSummary = {}));\n}(this, (function (exports) { 'use strict';\n\n    /**\n     * A helper class that maps from a DOM Node to an arbitrary value.\n     */\n    var NodeMap = /** @class */ (function () {\n        /**\n         * Constructs a new and empty NodeMap.\n         */\n        function NodeMap() {\n            this._nodes = [];\n            this._values = [];\n        }\n        NodeMap._isIndex = function (s) {\n            return +s === s >>> 0;\n        };\n        NodeMap._nodeId = function (node) {\n            var id = node[NodeMap._ID_PROP];\n            if (!id)\n                id = node[NodeMap._ID_PROP] = NodeMap._NEXT_ID++;\n            return id;\n        };\n        /**\n         * Sets the value of a node within the map.\n         * @param node  The node to set the value for.\n         * @param value the value to associate with the node.\n         */\n        NodeMap.prototype.set = function (node, value) {\n            var id = NodeMap._nodeId(node);\n            this._nodes[id] = node;\n            this._values[id] = value;\n        };\n        /**\n         * Gets the value for the given node.\n         *\n         * @param node The node to get the value of.\n         * @returns The value for the given node, or undefined if the node is not\n         * present in the map.\n         */\n        NodeMap.prototype.get = function (node) {\n            var id = NodeMap._nodeId(node);\n            return id !== undefined ? this._values[id] : undefined;\n        };\n        /**\n         * Determines if a given node is in the NodeMap.\n         *\n         * @param node The node to determine if it is in the map.\n         *\n         * @returns true if the Node is contained in the map, false otherwise.\n         */\n        NodeMap.prototype.has = function (node) {\n            return NodeMap._nodeId(node) in this._nodes;\n        };\n        /**\n         * Deletes a node from the NodeMap.\n         *\n         * @param node The node to delete.\n         */\n        NodeMap.prototype.delete = function (node) {\n            var id = NodeMap._nodeId(node);\n            delete this._nodes[id];\n            this._values[id] = undefined;\n        };\n        /**\n         * @returns an array that holds the nodes that are the keys of the map.\n         */\n        NodeMap.prototype.keys = function () {\n            var nodes = [];\n            for (var id in this._nodes) {\n                if (!NodeMap._isIndex(id))\n                    continue;\n                nodes.push(this._nodes[id]);\n            }\n            return nodes;\n        };\n        NodeMap._ID_PROP = '__mutation_summary_node_map_id__';\n        NodeMap._NEXT_ID = 1;\n        return NodeMap;\n    }());\n\n    var ChildListChange = /** @class */ (function () {\n        function ChildListChange() {\n            this.added = new NodeMap();\n            this.removed = new NodeMap();\n            this.maybeMoved = new NodeMap();\n            this.oldPrevious = new NodeMap();\n            this.moved = undefined;\n        }\n        return ChildListChange;\n    }());\n\n    exports.Movement = void 0;\n    (function (Movement) {\n        Movement[Movement[\"STAYED_OUT\"] = 0] = \"STAYED_OUT\";\n        Movement[Movement[\"ENTERED\"] = 1] = \"ENTERED\";\n        Movement[Movement[\"STAYED_IN\"] = 2] = \"STAYED_IN\";\n        Movement[Movement[\"REPARENTED\"] = 3] = \"REPARENTED\";\n        Movement[Movement[\"REORDERED\"] = 4] = \"REORDERED\";\n        Movement[Movement[\"EXITED\"] = 5] = \"EXITED\";\n    })(exports.Movement || (exports.Movement = {}));\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n    /* global Reflect, Promise */\r\n\r\n    var extendStatics = function(d, b) {\r\n        extendStatics = Object.setPrototypeOf ||\r\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n        return extendStatics(d, b);\r\n    };\r\n\r\n    function __extends(d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    }\n\n    var NodeChange = /** @class */ (function () {\n        function NodeChange(node, childList, attributes, characterData, oldParentNode, added, attributeOldValues, characterDataOldValue) {\n            if (childList === void 0) { childList = false; }\n            if (attributes === void 0) { attributes = false; }\n            if (characterData === void 0) { characterData = false; }\n            if (oldParentNode === void 0) { oldParentNode = null; }\n            if (added === void 0) { added = false; }\n            if (attributeOldValues === void 0) { attributeOldValues = null; }\n            if (characterDataOldValue === void 0) { characterDataOldValue = null; }\n            this.node = node;\n            this.childList = childList;\n            this.attributes = attributes;\n            this.characterData = characterData;\n            this.oldParentNode = oldParentNode;\n            this.added = added;\n            this.attributeOldValues = attributeOldValues;\n            this.characterDataOldValue = characterDataOldValue;\n            this.isCaseInsensitive =\n                this.node.nodeType === Node.ELEMENT_NODE &&\n                    this.node instanceof HTMLElement &&\n                    this.node.ownerDocument instanceof HTMLDocument;\n        }\n        NodeChange.prototype.getAttributeOldValue = function (name) {\n            if (!this.attributeOldValues)\n                return undefined;\n            if (this.isCaseInsensitive)\n                name = name.toLowerCase();\n            return this.attributeOldValues[name];\n        };\n        NodeChange.prototype.getAttributeNamesMutated = function () {\n            var names = [];\n            if (!this.attributeOldValues)\n                return names;\n            for (var name_1 in this.attributeOldValues) {\n                if (this.attributeOldValues.hasOwnProperty(name_1)) {\n                    names.push(name_1);\n                }\n            }\n            return names;\n        };\n        NodeChange.prototype.attributeMutated = function (name, oldValue) {\n            this.attributes = true;\n            this.attributeOldValues = this.attributeOldValues || {};\n            if (name in this.attributeOldValues)\n                return;\n            this.attributeOldValues[name] = oldValue;\n        };\n        NodeChange.prototype.characterDataMutated = function (oldValue) {\n            if (this.characterData)\n                return;\n            this.characterData = true;\n            this.characterDataOldValue = oldValue;\n        };\n        // Note: is it possible to receive a removal followed by a removal. This\n        // can occur if the removed node is added to an non-observed node, that\n        // node is added to the observed area, and then the node removed from\n        // it.\n        NodeChange.prototype.removedFromParent = function (parent) {\n            this.childList = true;\n            if (this.added || this.oldParentNode)\n                this.added = false;\n            else\n                this.oldParentNode = parent;\n        };\n        NodeChange.prototype.insertedIntoParent = function () {\n            this.childList = true;\n            this.added = true;\n        };\n        // An node's oldParent is\n        //   -its present parent, if its parentNode was not changed.\n        //   -null if the first thing that happened to it was an add.\n        //   -the node it was removed from if the first thing that happened to it\n        //      was a remove.\n        NodeChange.prototype.getOldParent = function () {\n            if (this.childList) {\n                if (this.oldParentNode)\n                    return this.oldParentNode;\n                if (this.added)\n                    return null;\n            }\n            return this.node.parentNode;\n        };\n        return NodeChange;\n    }());\n\n    var TreeChanges = /** @class */ (function (_super) {\n        __extends(TreeChanges, _super);\n        function TreeChanges(rootNode, mutations) {\n            var _this = _super.call(this) || this;\n            _this.rootNode = rootNode;\n            _this.reachableCache = undefined;\n            _this.wasReachableCache = undefined;\n            _this.anyParentsChanged = false;\n            _this.anyAttributesChanged = false;\n            _this.anyCharacterDataChanged = false;\n            for (var m = 0; m < mutations.length; m++) {\n                var mutation = mutations[m];\n                switch (mutation.type) {\n                    case 'childList':\n                        _this.anyParentsChanged = true;\n                        for (var i = 0; i < mutation.removedNodes.length; i++) {\n                            var node = mutation.removedNodes[i];\n                            _this.getChange(node).removedFromParent(mutation.target);\n                        }\n                        for (var i = 0; i < mutation.addedNodes.length; i++) {\n                            var node = mutation.addedNodes[i];\n                            _this.getChange(node).insertedIntoParent();\n                        }\n                        break;\n                    case 'attributes': {\n                        _this.anyAttributesChanged = true;\n                        var change = _this.getChange(mutation.target);\n                        change.attributeMutated(mutation.attributeName, mutation.oldValue);\n                        break;\n                    }\n                    case 'characterData': {\n                        _this.anyCharacterDataChanged = true;\n                        var change = _this.getChange(mutation.target);\n                        change.characterDataMutated(mutation.oldValue);\n                        break;\n                    }\n                }\n            }\n            return _this;\n        }\n        TreeChanges.prototype.getChange = function (node) {\n            var change = this.get(node);\n            if (!change) {\n                change = new NodeChange(node);\n                this.set(node, change);\n            }\n            return change;\n        };\n        TreeChanges.prototype.getOldParent = function (node) {\n            var change = this.get(node);\n            return change ? change.getOldParent() : node.parentNode;\n        };\n        TreeChanges.prototype.getIsReachable = function (node) {\n            if (node === this.rootNode)\n                return true;\n            if (!node)\n                return false;\n            this.reachableCache = this.reachableCache || new NodeMap();\n            var isReachable = this.reachableCache.get(node);\n            if (isReachable === undefined) {\n                isReachable = this.getIsReachable(node.parentNode);\n                this.reachableCache.set(node, isReachable);\n            }\n            return isReachable;\n        };\n        // A node wasReachable if its oldParent wasReachable.\n        TreeChanges.prototype.getWasReachable = function (node) {\n            if (node === this.rootNode)\n                return true;\n            if (!node)\n                return false;\n            this.wasReachableCache = this.wasReachableCache || new NodeMap();\n            var wasReachable = this.wasReachableCache.get(node);\n            if (wasReachable === undefined) {\n                wasReachable = this.getWasReachable(this.getOldParent(node));\n                this.wasReachableCache.set(node, wasReachable);\n            }\n            return wasReachable;\n        };\n        TreeChanges.prototype.reachabilityChange = function (node) {\n            if (this.getIsReachable(node)) {\n                return this.getWasReachable(node) ?\n                    exports.Movement.STAYED_IN : exports.Movement.ENTERED;\n            }\n            return this.getWasReachable(node) ?\n                exports.Movement.EXITED : exports.Movement.STAYED_OUT;\n        };\n        return TreeChanges;\n    }(NodeMap));\n\n    var MutationProjection = /** @class */ (function () {\n        // TOOD(any)\n        function MutationProjection(rootNode, mutations, selectors, calcReordered, calcOldPreviousSibling) {\n            this.rootNode = rootNode;\n            this.mutations = mutations;\n            this.selectors = selectors;\n            this.calcReordered = calcReordered;\n            this.calcOldPreviousSibling = calcOldPreviousSibling;\n            this.treeChanges = new TreeChanges(rootNode, mutations);\n            this.entered = [];\n            this.exited = [];\n            this.stayedIn = new NodeMap();\n            this.visited = new NodeMap();\n            this.childListChangeMap = undefined;\n            this.characterDataOnly = undefined;\n            this.matchCache = undefined;\n            this.processMutations();\n        }\n        MutationProjection.prototype.processMutations = function () {\n            if (!this.treeChanges.anyParentsChanged &&\n                !this.treeChanges.anyAttributesChanged)\n                return;\n            var changedNodes = this.treeChanges.keys();\n            for (var i = 0; i < changedNodes.length; i++) {\n                this.visitNode(changedNodes[i], undefined);\n            }\n        };\n        MutationProjection.prototype.visitNode = function (node, parentReachable) {\n            if (this.visited.has(node))\n                return;\n            this.visited.set(node, true);\n            var change = this.treeChanges.get(node);\n            var reachable = parentReachable;\n            // node inherits its parent's reachability change unless\n            // its parentNode was mutated.\n            if ((change && change.childList) || reachable == undefined)\n                reachable = this.treeChanges.reachabilityChange(node);\n            if (reachable === exports.Movement.STAYED_OUT)\n                return;\n            // Cache match results for sub-patterns.\n            this.matchabilityChange(node);\n            if (reachable === exports.Movement.ENTERED) {\n                this.entered.push(node);\n            }\n            else if (reachable === exports.Movement.EXITED) {\n                this.exited.push(node);\n                this.ensureHasOldPreviousSiblingIfNeeded(node);\n            }\n            else if (reachable === exports.Movement.STAYED_IN) {\n                var movement = exports.Movement.STAYED_IN;\n                if (change && change.childList) {\n                    if (change.oldParentNode !== node.parentNode) {\n                        movement = exports.Movement.REPARENTED;\n                        this.ensureHasOldPreviousSiblingIfNeeded(node);\n                    }\n                    else if (this.calcReordered && this.wasReordered(node)) {\n                        movement = exports.Movement.REORDERED;\n                    }\n                }\n                this.stayedIn.set(node, movement);\n            }\n            if (reachable === exports.Movement.STAYED_IN)\n                return;\n            // reachable === ENTERED || reachable === EXITED.\n            for (var child = node.firstChild; child; child = child.nextSibling) {\n                this.visitNode(child, reachable);\n            }\n        };\n        MutationProjection.prototype.ensureHasOldPreviousSiblingIfNeeded = function (node) {\n            if (!this.calcOldPreviousSibling)\n                return;\n            this.processChildlistChanges();\n            var parentNode = node.parentNode;\n            var nodeChange = this.treeChanges.get(node);\n            if (nodeChange && nodeChange.oldParentNode)\n                parentNode = nodeChange.oldParentNode;\n            var change = this.childListChangeMap.get(parentNode);\n            if (!change) {\n                change = new ChildListChange();\n                this.childListChangeMap.set(parentNode, change);\n            }\n            if (!change.oldPrevious.has(node)) {\n                change.oldPrevious.set(node, node.previousSibling);\n            }\n        };\n        MutationProjection.prototype.getChanged = function (summary, selectors, characterDataOnly) {\n            this.selectors = selectors;\n            this.characterDataOnly = characterDataOnly;\n            for (var i = 0; i < this.entered.length; i++) {\n                var node = this.entered[i];\n                var matchable = this.matchabilityChange(node);\n                if (matchable === exports.Movement.ENTERED || matchable === exports.Movement.STAYED_IN)\n                    summary.added.push(node);\n            }\n            var stayedInNodes = this.stayedIn.keys();\n            for (var i = 0; i < stayedInNodes.length; i++) {\n                var node = stayedInNodes[i];\n                var matchable = this.matchabilityChange(node);\n                if (matchable === exports.Movement.ENTERED) {\n                    summary.added.push(node);\n                }\n                else if (matchable === exports.Movement.EXITED) {\n                    summary.removed.push(node);\n                }\n                else if (matchable === exports.Movement.STAYED_IN && (summary.reparented || summary.reordered)) {\n                    var movement = this.stayedIn.get(node);\n                    if (summary.reparented && movement === exports.Movement.REPARENTED)\n                        summary.reparented.push(node);\n                    else if (summary.reordered && movement === exports.Movement.REORDERED)\n                        summary.reordered.push(node);\n                }\n            }\n            for (var i = 0; i < this.exited.length; i++) {\n                var node = this.exited[i];\n                var matchable = this.matchabilityChange(node);\n                if (matchable === exports.Movement.EXITED || matchable === exports.Movement.STAYED_IN)\n                    summary.removed.push(node);\n            }\n        };\n        MutationProjection.prototype.getOldParentNode = function (node) {\n            var change = this.treeChanges.get(node);\n            if (change && change.childList)\n                return change.oldParentNode ? change.oldParentNode : null;\n            var reachabilityChange = this.treeChanges.reachabilityChange(node);\n            if (reachabilityChange === exports.Movement.STAYED_OUT || reachabilityChange === exports.Movement.ENTERED)\n                throw Error('getOldParentNode requested on invalid node.');\n            return node.parentNode;\n        };\n        MutationProjection.prototype.getOldPreviousSibling = function (node) {\n            var parentNode = node.parentNode;\n            var nodeChange = this.treeChanges.get(node);\n            if (nodeChange && nodeChange.oldParentNode)\n                parentNode = nodeChange.oldParentNode;\n            var change = this.childListChangeMap.get(parentNode);\n            if (!change)\n                throw Error('getOldPreviousSibling requested on invalid node.');\n            return change.oldPrevious.get(node);\n        };\n        MutationProjection.prototype.getOldAttribute = function (element, attrName) {\n            var change = this.treeChanges.get(element);\n            if (!change || !change.attributes)\n                throw Error('getOldAttribute requested on invalid node.');\n            var value = change.getAttributeOldValue(attrName);\n            if (value === undefined)\n                throw Error('getOldAttribute requested for unchanged attribute name.');\n            return value;\n        };\n        MutationProjection.prototype.attributeChangedNodes = function (includeAttributes) {\n            if (!this.treeChanges.anyAttributesChanged)\n                return {}; // No attributes mutations occurred.\n            var attributeFilter;\n            var caseInsensitiveFilter;\n            if (includeAttributes) {\n                attributeFilter = {};\n                caseInsensitiveFilter = {};\n                for (var i = 0; i < includeAttributes.length; i++) {\n                    var attrName = includeAttributes[i];\n                    attributeFilter[attrName] = true;\n                    caseInsensitiveFilter[attrName.toLowerCase()] = attrName;\n                }\n            }\n            var result = {};\n            var nodes = this.treeChanges.keys();\n            for (var i = 0; i < nodes.length; i++) {\n                var node = nodes[i];\n                var change = this.treeChanges.get(node);\n                if (!change.attributes)\n                    continue;\n                if (exports.Movement.STAYED_IN !== this.treeChanges.reachabilityChange(node) ||\n                    exports.Movement.STAYED_IN !== this.matchabilityChange(node)) {\n                    continue;\n                }\n                var element = node;\n                var changedAttrNames = change.getAttributeNamesMutated();\n                for (var j = 0; j < changedAttrNames.length; j++) {\n                    var attrName = changedAttrNames[j];\n                    if (attributeFilter &&\n                        !attributeFilter[attrName] &&\n                        !(change.isCaseInsensitive && caseInsensitiveFilter[attrName])) {\n                        continue;\n                    }\n                    var oldValue = change.getAttributeOldValue(attrName);\n                    if (oldValue === element.getAttribute(attrName))\n                        continue;\n                    if (caseInsensitiveFilter && change.isCaseInsensitive)\n                        attrName = caseInsensitiveFilter[attrName];\n                    result[attrName] = result[attrName] || [];\n                    result[attrName].push(element);\n                }\n            }\n            return result;\n        };\n        MutationProjection.prototype.getOldCharacterData = function (node) {\n            var change = this.treeChanges.get(node);\n            if (!change || !change.characterData)\n                throw Error('getOldCharacterData requested on invalid node.');\n            return change.characterDataOldValue;\n        };\n        MutationProjection.prototype.getCharacterDataChanged = function () {\n            if (!this.treeChanges.anyCharacterDataChanged)\n                return []; // No characterData mutations occurred.\n            var nodes = this.treeChanges.keys();\n            var result = [];\n            for (var i = 0; i < nodes.length; i++) {\n                var target = nodes[i];\n                if (exports.Movement.STAYED_IN !== this.treeChanges.reachabilityChange(target))\n                    continue;\n                var change = this.treeChanges.get(target);\n                if (!change.characterData ||\n                    target.textContent == change.characterDataOldValue)\n                    continue;\n                result.push(target);\n            }\n            return result;\n        };\n        MutationProjection.prototype.computeMatchabilityChange = function (selector, el) {\n            if (!this.matchCache)\n                this.matchCache = [];\n            if (!this.matchCache[selector.uid])\n                this.matchCache[selector.uid] = new NodeMap();\n            var cache = this.matchCache[selector.uid];\n            var result = cache.get(el);\n            if (result === undefined) {\n                result = selector.matchabilityChange(el, this.treeChanges.get(el));\n                cache.set(el, result);\n            }\n            return result;\n        };\n        MutationProjection.prototype.matchabilityChange = function (node) {\n            var _this = this;\n            // TODO(rafaelw): Include PI, CDATA?\n            // Only include text nodes.\n            if (this.characterDataOnly) {\n                switch (node.nodeType) {\n                    case Node.COMMENT_NODE:\n                    case Node.TEXT_NODE:\n                        return exports.Movement.STAYED_IN;\n                    default:\n                        return exports.Movement.STAYED_OUT;\n                }\n            }\n            // No element filter. Include all nodes.\n            if (!this.selectors)\n                return exports.Movement.STAYED_IN;\n            // Element filter. Exclude non-elements.\n            if (node.nodeType !== Node.ELEMENT_NODE)\n                return exports.Movement.STAYED_OUT;\n            var el = node;\n            var matchChanges = this.selectors.map(function (selector) {\n                return _this.computeMatchabilityChange(selector, el);\n            });\n            var accum = exports.Movement.STAYED_OUT;\n            var i = 0;\n            while (accum !== exports.Movement.STAYED_IN && i < matchChanges.length) {\n                switch (matchChanges[i]) {\n                    case exports.Movement.STAYED_IN:\n                        accum = exports.Movement.STAYED_IN;\n                        break;\n                    case exports.Movement.ENTERED:\n                        if (accum === exports.Movement.EXITED)\n                            accum = exports.Movement.STAYED_IN;\n                        else\n                            accum = exports.Movement.ENTERED;\n                        break;\n                    case exports.Movement.EXITED:\n                        if (accum === exports.Movement.ENTERED)\n                            accum = exports.Movement.STAYED_IN;\n                        else\n                            accum = exports.Movement.EXITED;\n                        break;\n                }\n                i++;\n            }\n            return accum;\n        };\n        MutationProjection.prototype.getChildlistChange = function (el) {\n            var change = this.childListChangeMap.get(el);\n            if (!change) {\n                change = new ChildListChange();\n                this.childListChangeMap.set(el, change);\n            }\n            return change;\n        };\n        MutationProjection.prototype.processChildlistChanges = function () {\n            if (this.childListChangeMap)\n                return;\n            this.childListChangeMap = new NodeMap();\n            var _loop_1 = function (i) {\n                var mutation = this_1.mutations[i];\n                if (mutation.type != 'childList')\n                    return \"continue\";\n                if (this_1.treeChanges.reachabilityChange(mutation.target) !== exports.Movement.STAYED_IN &&\n                    !this_1.calcOldPreviousSibling)\n                    return \"continue\";\n                var change = this_1.getChildlistChange(mutation.target);\n                var oldPrevious = mutation.previousSibling;\n                var recordOldPrevious = function (node, previous) {\n                    if (!node ||\n                        change.oldPrevious.has(node) ||\n                        change.added.has(node) ||\n                        change.maybeMoved.has(node))\n                        return;\n                    if (previous &&\n                        (change.added.has(previous) ||\n                            change.maybeMoved.has(previous)))\n                        return;\n                    change.oldPrevious.set(node, previous);\n                };\n                for (var j = 0; j < mutation.removedNodes.length; j++) {\n                    var node = mutation.removedNodes[j];\n                    recordOldPrevious(node, oldPrevious);\n                    if (change.added.has(node)) {\n                        change.added.delete(node);\n                    }\n                    else {\n                        change.removed.set(node, true);\n                        change.maybeMoved.delete(node);\n                    }\n                    oldPrevious = node;\n                }\n                recordOldPrevious(mutation.nextSibling, oldPrevious);\n                for (var j = 0; j < mutation.addedNodes.length; j++) {\n                    var node = mutation.addedNodes[j];\n                    if (change.removed.has(node)) {\n                        change.removed.delete(node);\n                        change.maybeMoved.set(node, true);\n                    }\n                    else {\n                        change.added.set(node, true);\n                    }\n                }\n            };\n            var this_1 = this;\n            for (var i = 0; i < this.mutations.length; i++) {\n                _loop_1(i);\n            }\n        };\n        MutationProjection.prototype.wasReordered = function (node) {\n            if (!this.treeChanges.anyParentsChanged)\n                return false;\n            this.processChildlistChanges();\n            var parentNode = node.parentNode;\n            var nodeChange = this.treeChanges.get(node);\n            if (nodeChange && nodeChange.oldParentNode)\n                parentNode = nodeChange.oldParentNode;\n            var change = this.childListChangeMap.get(parentNode);\n            if (!change)\n                return false;\n            if (change.moved)\n                return change.moved.get(node);\n            change.moved = new NodeMap();\n            var pendingMoveDecision = new NodeMap();\n            function isMoved(node) {\n                if (!node)\n                    return false;\n                if (!change.maybeMoved.has(node))\n                    return false;\n                var didMove = change.moved.get(node);\n                if (didMove !== undefined)\n                    return didMove;\n                if (pendingMoveDecision.has(node)) {\n                    didMove = true;\n                }\n                else {\n                    pendingMoveDecision.set(node, true);\n                    didMove = getPrevious(node) !== getOldPrevious(node);\n                }\n                if (pendingMoveDecision.has(node)) {\n                    pendingMoveDecision.delete(node);\n                    change.moved.set(node, didMove);\n                }\n                else {\n                    didMove = change.moved.get(node);\n                }\n                return didMove;\n            }\n            var oldPreviousCache = new NodeMap();\n            function getOldPrevious(node) {\n                var oldPrevious = oldPreviousCache.get(node);\n                if (oldPrevious !== undefined)\n                    return oldPrevious;\n                oldPrevious = change.oldPrevious.get(node);\n                while (oldPrevious &&\n                    (change.removed.has(oldPrevious) || isMoved(oldPrevious))) {\n                    oldPrevious = getOldPrevious(oldPrevious);\n                }\n                if (oldPrevious === undefined)\n                    oldPrevious = node.previousSibling;\n                oldPreviousCache.set(node, oldPrevious);\n                return oldPrevious;\n            }\n            var previousCache = new NodeMap();\n            function getPrevious(node) {\n                if (previousCache.has(node))\n                    return previousCache.get(node);\n                var previous = node.previousSibling;\n                while (previous && (change.added.has(previous) || isMoved(previous)))\n                    previous = previous.previousSibling;\n                previousCache.set(node, previous);\n                return previous;\n            }\n            change.maybeMoved.keys().forEach(isMoved);\n            return change.moved.get(node);\n        };\n        return MutationProjection;\n    }());\n\n    /**\n     * Represents a set of changes made to the DOM.\n     */\n    var Summary = /** @class */ (function () {\n        /**\n         * Creates a new Summary instance given a [[MutationProjection]] and the\n         * [[IQuery]] that was responsible for this summary being generated.\n         *\n         * @param projection The projection containing the changes.\n         * @param query The query that cause the summary to be created.\n         */\n        function Summary(projection, query) {\n            var _this = this;\n            this.projection = projection;\n            this.added = [];\n            this.removed = [];\n            this.reparented = query.all || query.element || query.characterData ? [] : undefined;\n            this.reordered = query.all ? [] : undefined;\n            projection.getChanged(this, query.elementFilter, query.characterData);\n            if (query.all || query.attribute || query.attributeList) {\n                var filter = query.attribute ? [query.attribute] : query.attributeList;\n                var attributeChanged = projection.attributeChangedNodes(filter);\n                if (query.attribute) {\n                    this.valueChanged = attributeChanged[query.attribute] || [];\n                }\n                else {\n                    this.attributeChanged = attributeChanged;\n                    if (query.attributeList) {\n                        query.attributeList.forEach(function (attrName) {\n                            if (!_this.attributeChanged.hasOwnProperty(attrName))\n                                _this.attributeChanged[attrName] = [];\n                        });\n                    }\n                }\n            }\n            if (query.all || query.characterData) {\n                var characterDataChanged = projection.getCharacterDataChanged();\n                if (query.characterData)\n                    this.valueChanged = characterDataChanged;\n                else\n                    this.characterDataChanged = characterDataChanged;\n            }\n            // TODO this seems unnecessary.\n            if (this.reordered)\n                this.getOldPreviousSibling = projection.getOldPreviousSibling.bind(projection);\n        }\n        /**\n         * Will retrieve the previous parentNode for and node. The node must be\n         * contained in the removed element array, otherwise the function throws an\n         * error.\n         *\n         * @param node The node to get the previous parent for.\n         */\n        Summary.prototype.getOldParentNode = function (node) {\n            return this.projection.getOldParentNode(node);\n        };\n        /**\n         * Retrieves the previous value of an attribute for an element. The Element\n         * must be contained in the valueChanged element array, otherwise the\n         * function throws an error.\n         *\n         * @param element The element to ge the old value for.\n         * @param name The name off the attribute on the element to get the old value\n         * for.\n         */\n        Summary.prototype.getOldAttribute = function (element, name) {\n            return this.projection.getOldAttribute(element, name);\n        };\n        /**\n         * Retrieves the previous text of `node`. `node` must be  contained in the\n         * `valueChanged` node array, otherwise the function throws an error.\n         *\n         * @param node The node to get the old character data for.\n         */\n        Summary.prototype.getOldCharacterData = function (node) {\n            return this.projection.getOldCharacterData(node);\n        };\n        /**\n         * Retrieves the previous previousSibling for a node. The node must be\n         * contained in the reordered element array, otherwise the function throws\n         * an error.\n         *\n         * @param node The node to get the previous sibling for.\n         */\n        Summary.prototype.getOldPreviousSibling = function (node) {\n            return this.projection.getOldPreviousSibling(node);\n        };\n        return Summary;\n    }());\n\n    var Qualifier = /** @class */ (function () {\n        function Qualifier() {\n        }\n        Qualifier.prototype.matches = function (oldValue) {\n            if (oldValue === null)\n                return false;\n            if (this.attrValue === undefined)\n                return true;\n            if (!this.contains)\n                return this.attrValue == oldValue;\n            var tokens = oldValue.split(' ');\n            for (var i = 0; i < tokens.length; i++) {\n                if (this.attrValue === tokens[i])\n                    return true;\n            }\n            return false;\n        };\n        Qualifier.prototype.toString = function () {\n            if (this.attrName === 'class' && this.contains)\n                return '.' + this.attrValue;\n            if (this.attrName === 'id' && !this.contains)\n                return '#' + this.attrValue;\n            if (this.contains)\n                return '[' + this.attrName + '~=' + escapeQuotes(this.attrValue) + ']';\n            if ('attrValue' in this)\n                return '[' + this.attrName + '=' + escapeQuotes(this.attrValue) + ']';\n            //@ts-ignore\n            return '[' + this.attrName + ']';\n        };\n        return Qualifier;\n    }());\n    function escapeQuotes(value) {\n        return '\"' + value.replace(/\"/, '\\\\\\\"') + '\"';\n    }\n\n    // TODO(rafaelw): Allow ':' and '.' as valid name characters.\n    var validNameInitialChar = /[a-zA-Z_]+/;\n    var validNameNonInitialChar = /[a-zA-Z0-9_\\-]+/;\n    var Selector = /** @class */ (function () {\n        function Selector() {\n            this.uid = Selector.nextUid++;\n            this.qualifiers = [];\n        }\n        Object.defineProperty(Selector.prototype, \"caseInsensitiveTagName\", {\n            get: function () {\n                return this.tagName.toUpperCase();\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Object.defineProperty(Selector.prototype, \"selectorString\", {\n            get: function () {\n                return this.tagName + this.qualifiers.join('');\n            },\n            enumerable: false,\n            configurable: true\n        });\n        Selector.prototype.isMatching = function (el) {\n            return el[Selector.matchesSelector](this.selectorString);\n        };\n        Selector.prototype.wasMatching = function (el, change, isMatching) {\n            if (!change || !change.attributes)\n                return isMatching;\n            var tagName = change.isCaseInsensitive ? this.caseInsensitiveTagName : this.tagName;\n            if (tagName !== '*' && tagName !== el.tagName)\n                return false;\n            var attributeOldValues = [];\n            var anyChanged = false;\n            for (var i = 0; i < this.qualifiers.length; i++) {\n                var qualifier = this.qualifiers[i];\n                var oldValue = change.getAttributeOldValue(qualifier.attrName);\n                attributeOldValues.push(oldValue);\n                anyChanged = anyChanged || (oldValue !== undefined);\n            }\n            if (!anyChanged)\n                return isMatching;\n            for (var i = 0; i < this.qualifiers.length; i++) {\n                var qualifier = this.qualifiers[i];\n                var oldValue = attributeOldValues[i];\n                if (oldValue === undefined)\n                    oldValue = el.getAttribute(qualifier.attrName);\n                if (!qualifier.matches(oldValue))\n                    return false;\n            }\n            return true;\n        };\n        Selector.prototype.matchabilityChange = function (el, change) {\n            var isMatching = this.isMatching(el);\n            if (isMatching)\n                return this.wasMatching(el, change, isMatching) ? exports.Movement.STAYED_IN : exports.Movement.ENTERED;\n            else\n                return this.wasMatching(el, change, isMatching) ? exports.Movement.EXITED : exports.Movement.STAYED_OUT;\n        };\n        Selector.parseSelectors = function (input) {\n            var selectors = [];\n            var currentSelector;\n            var currentQualifier;\n            function newSelector() {\n                if (currentSelector) {\n                    if (currentQualifier) {\n                        currentSelector.qualifiers.push(currentQualifier);\n                        currentQualifier = undefined;\n                    }\n                    selectors.push(currentSelector);\n                }\n                currentSelector = new Selector();\n            }\n            function newQualifier() {\n                if (currentQualifier)\n                    currentSelector.qualifiers.push(currentQualifier);\n                currentQualifier = new Qualifier();\n            }\n            var WHITESPACE = /\\s/;\n            var valueQuoteChar = undefined;\n            var SYNTAX_ERROR = 'Invalid or unsupported selector syntax.';\n            var SELECTOR = 1;\n            var TAG_NAME = 2;\n            var QUALIFIER = 3;\n            var QUALIFIER_NAME_FIRST_CHAR = 4;\n            var QUALIFIER_NAME = 5;\n            var ATTR_NAME_FIRST_CHAR = 6;\n            var ATTR_NAME = 7;\n            var EQUIV_OR_ATTR_QUAL_END = 8;\n            var EQUAL = 9;\n            var ATTR_QUAL_END = 10;\n            var VALUE_FIRST_CHAR = 11;\n            var VALUE = 12;\n            var QUOTED_VALUE = 13;\n            var SELECTOR_SEPARATOR = 14;\n            var state = SELECTOR;\n            var i = 0;\n            while (i < input.length) {\n                var c = input[i++];\n                switch (state) {\n                    case SELECTOR:\n                        if (c.match(validNameInitialChar)) {\n                            newSelector();\n                            currentSelector.tagName = c;\n                            state = TAG_NAME;\n                            break;\n                        }\n                        if (c == '*') {\n                            newSelector();\n                            currentSelector.tagName = '*';\n                            state = QUALIFIER;\n                            break;\n                        }\n                        if (c == '.') {\n                            newSelector();\n                            newQualifier();\n                            currentSelector.tagName = '*';\n                            currentQualifier.attrName = 'class';\n                            currentQualifier.contains = true;\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '#') {\n                            newSelector();\n                            newQualifier();\n                            currentSelector.tagName = '*';\n                            currentQualifier.attrName = 'id';\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '[') {\n                            newSelector();\n                            newQualifier();\n                            currentSelector.tagName = '*';\n                            currentQualifier.attrName = '';\n                            state = ATTR_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c.match(WHITESPACE))\n                            break;\n                        throw Error(SYNTAX_ERROR);\n                    case TAG_NAME:\n                        if (c.match(validNameNonInitialChar)) {\n                            currentSelector.tagName += c;\n                            break;\n                        }\n                        if (c == '.') {\n                            newQualifier();\n                            currentQualifier.attrName = 'class';\n                            currentQualifier.contains = true;\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '#') {\n                            newQualifier();\n                            currentQualifier.attrName = 'id';\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '[') {\n                            newQualifier();\n                            currentQualifier.attrName = '';\n                            state = ATTR_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c.match(WHITESPACE)) {\n                            state = SELECTOR_SEPARATOR;\n                            break;\n                        }\n                        if (c == ',') {\n                            state = SELECTOR;\n                            break;\n                        }\n                        throw Error(SYNTAX_ERROR);\n                    case QUALIFIER:\n                        if (c == '.') {\n                            newQualifier();\n                            currentQualifier.attrName = 'class';\n                            currentQualifier.contains = true;\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '#') {\n                            newQualifier();\n                            currentQualifier.attrName = 'id';\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '[') {\n                            newQualifier();\n                            currentQualifier.attrName = '';\n                            state = ATTR_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c.match(WHITESPACE)) {\n                            state = SELECTOR_SEPARATOR;\n                            break;\n                        }\n                        if (c == ',') {\n                            state = SELECTOR;\n                            break;\n                        }\n                        throw Error(SYNTAX_ERROR);\n                    case QUALIFIER_NAME_FIRST_CHAR:\n                        if (c.match(validNameInitialChar)) {\n                            currentQualifier.attrValue = c;\n                            state = QUALIFIER_NAME;\n                            break;\n                        }\n                        throw Error(SYNTAX_ERROR);\n                    case QUALIFIER_NAME:\n                        if (c.match(validNameNonInitialChar)) {\n                            currentQualifier.attrValue += c;\n                            break;\n                        }\n                        if (c == '.') {\n                            newQualifier();\n                            currentQualifier.attrName = 'class';\n                            currentQualifier.contains = true;\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '#') {\n                            newQualifier();\n                            currentQualifier.attrName = 'id';\n                            state = QUALIFIER_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == '[') {\n                            newQualifier();\n                            state = ATTR_NAME_FIRST_CHAR;\n                            break;\n                        }\n                        if (c.match(WHITESPACE)) {\n                            state = SELECTOR_SEPARATOR;\n                            break;\n                        }\n                        if (c == ',') {\n                            state = SELECTOR;\n                            break;\n                        }\n                        throw Error(SYNTAX_ERROR);\n                    case ATTR_NAME_FIRST_CHAR:\n                        if (c.match(validNameInitialChar)) {\n                            currentQualifier.attrName = c;\n                            state = ATTR_NAME;\n                            break;\n                        }\n                        if (c.match(WHITESPACE))\n                            break;\n                        throw Error(SYNTAX_ERROR);\n                    case ATTR_NAME:\n                        if (c.match(validNameNonInitialChar)) {\n                            currentQualifier.attrName += c;\n                            break;\n                        }\n                        if (c.match(WHITESPACE)) {\n                            state = EQUIV_OR_ATTR_QUAL_END;\n                            break;\n                        }\n                        if (c == '~') {\n                            currentQualifier.contains = true;\n                            state = EQUAL;\n                            break;\n                        }\n                        if (c == '=') {\n                            currentQualifier.attrValue = '';\n                            state = VALUE_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == ']') {\n                            state = QUALIFIER;\n                            break;\n                        }\n                        throw Error(SYNTAX_ERROR);\n                    case EQUIV_OR_ATTR_QUAL_END:\n                        if (c == '~') {\n                            currentQualifier.contains = true;\n                            state = EQUAL;\n                            break;\n                        }\n                        if (c == '=') {\n                            currentQualifier.attrValue = '';\n                            state = VALUE_FIRST_CHAR;\n                            break;\n                        }\n                        if (c == ']') {\n                            state = QUALIFIER;\n                            break;\n                        }\n                        if (c.match(WHITESPACE))\n                            break;\n                        throw Error(SYNTAX_ERROR);\n                    case EQUAL:\n                        if (c == '=') {\n                            currentQualifier.attrValue = '';\n                            state = VALUE_FIRST_CHAR;\n                            break;\n                        }\n                        throw Error(SYNTAX_ERROR);\n                    case ATTR_QUAL_END:\n                        if (c == ']') {\n                            state = QUALIFIER;\n                            break;\n                        }\n                        if (c.match(WHITESPACE))\n                            break;\n                        throw Error(SYNTAX_ERROR);\n                    case VALUE_FIRST_CHAR:\n                        if (c.match(WHITESPACE))\n                            break;\n                        if (c == '\"' || c == \"'\") {\n                            valueQuoteChar = c;\n                            state = QUOTED_VALUE;\n                            break;\n                        }\n                        currentQualifier.attrValue += c;\n                        state = VALUE;\n                        break;\n                    case VALUE:\n                        if (c.match(WHITESPACE)) {\n                            state = ATTR_QUAL_END;\n                            break;\n                        }\n                        if (c == ']') {\n                            state = QUALIFIER;\n                            break;\n                        }\n                        if (c == \"'\" || c == '\"')\n                            throw Error(SYNTAX_ERROR);\n                        currentQualifier.attrValue += c;\n                        break;\n                    case QUOTED_VALUE:\n                        if (c == valueQuoteChar) {\n                            state = ATTR_QUAL_END;\n                            break;\n                        }\n                        currentQualifier.attrValue += c;\n                        break;\n                    case SELECTOR_SEPARATOR:\n                        if (c.match(WHITESPACE))\n                            break;\n                        if (c == ',') {\n                            state = SELECTOR;\n                            break;\n                        }\n                        throw Error(SYNTAX_ERROR);\n                }\n            }\n            switch (state) {\n                case SELECTOR:\n                case TAG_NAME:\n                case QUALIFIER:\n                case QUALIFIER_NAME:\n                case SELECTOR_SEPARATOR:\n                    // Valid end states.\n                    newSelector();\n                    break;\n                default:\n                    throw Error(SYNTAX_ERROR);\n            }\n            if (!selectors.length)\n                throw Error(SYNTAX_ERROR);\n            return selectors;\n        };\n        Selector.nextUid = 1;\n        Selector.matchesSelector = \"matches\";\n        return Selector;\n    }());\n\n    var MutationSummaryOptionProcessor = /** @class */ (function () {\n        function MutationSummaryOptionProcessor() {\n        }\n        MutationSummaryOptionProcessor.createObserverOptions = function (queries) {\n            var observerOptions = {\n                childList: true,\n                subtree: true\n            };\n            var attributeFilter;\n            function observeAttributes(attributes) {\n                if (observerOptions.attributes && !attributeFilter)\n                    return; // already observing all.\n                observerOptions.attributes = true;\n                observerOptions.attributeOldValue = true;\n                if (!attributes) {\n                    // observe all.\n                    attributeFilter = undefined;\n                    return;\n                }\n                // add to observed.\n                attributeFilter = attributeFilter || {};\n                attributes.forEach(function (attribute) {\n                    attributeFilter[attribute] = true;\n                    attributeFilter[attribute.toLowerCase()] = true;\n                });\n            }\n            queries.forEach(function (query) {\n                if (query.characterData) {\n                    observerOptions.characterData = true;\n                    observerOptions.characterDataOldValue = true;\n                    return;\n                }\n                if (query.all) {\n                    observeAttributes();\n                    observerOptions.characterData = true;\n                    observerOptions.characterDataOldValue = true;\n                    return;\n                }\n                if (query.attribute) {\n                    observeAttributes([query.attribute.trim()]);\n                    return;\n                }\n                var attributes = MutationSummaryOptionProcessor._elementFilterAttributes(query.elementFilter).concat(query.attributeList || []);\n                if (attributes.length)\n                    observeAttributes(attributes);\n            });\n            if (attributeFilter)\n                observerOptions.attributeFilter = Object.keys(attributeFilter);\n            return observerOptions;\n        };\n        MutationSummaryOptionProcessor.validateOptions = function (options) {\n            for (var prop in options) {\n                if (!(prop in MutationSummaryOptionProcessor._optionKeys))\n                    throw Error('Invalid option: ' + prop);\n            }\n            if (typeof options.callback !== 'function')\n                throw Error('Invalid options: callback is required and must be a function');\n            if (!options.queries || !options.queries.length)\n                throw Error('Invalid options: queries must contain at least one query request object.');\n            var opts = {\n                callback: options.callback,\n                rootNode: options.rootNode || document,\n                observeOwnChanges: !!options.observeOwnChanges,\n                oldPreviousSibling: !!options.oldPreviousSibling,\n                queries: []\n            };\n            for (var i = 0; i < options.queries.length; i++) {\n                var request = options.queries[i];\n                // all\n                if (request.all) {\n                    if (Object.keys(request).length > 1)\n                        throw Error('Invalid request option. all has no options.');\n                    opts.queries.push({ all: true });\n                    continue;\n                }\n                // attribute\n                if ('attribute' in request) {\n                    var query = {\n                        attribute: MutationSummaryOptionProcessor._validateAttribute(request.attribute)\n                    };\n                    query.elementFilter = Selector.parseSelectors('*[' + query.attribute + ']');\n                    if (Object.keys(request).length > 1)\n                        throw Error('Invalid request option. attribute has no options.');\n                    opts.queries.push(query);\n                    continue;\n                }\n                // element\n                if ('element' in request) {\n                    var requestOptionCount = Object.keys(request).length;\n                    var query = {\n                        element: request.element,\n                        elementFilter: Selector.parseSelectors(request.element)\n                    };\n                    if (request.hasOwnProperty('elementAttributes')) {\n                        query.attributeList = MutationSummaryOptionProcessor._validateElementAttributes(request.elementAttributes);\n                        requestOptionCount--;\n                    }\n                    if (requestOptionCount > 1)\n                        throw Error('Invalid request option. element only allows elementAttributes option.');\n                    opts.queries.push(query);\n                    continue;\n                }\n                // characterData\n                if (request.characterData) {\n                    if (Object.keys(request).length > 1)\n                        throw Error('Invalid request option. characterData has no options.');\n                    opts.queries.push({ characterData: true });\n                    continue;\n                }\n                throw Error('Invalid request option. Unknown query request.');\n            }\n            return opts;\n        };\n        MutationSummaryOptionProcessor._validateElementAttributes = function (attribs) {\n            if (!attribs.trim().length)\n                throw Error('Invalid request option: elementAttributes must contain at least one attribute.');\n            var lowerAttributes = {};\n            var attributes = {};\n            var tokens = attribs.split(/\\s+/);\n            for (var i = 0; i < tokens.length; i++) {\n                var name_1 = tokens[i];\n                if (!name_1)\n                    continue;\n                name_1 = MutationSummaryOptionProcessor._validateAttribute(name_1);\n                var nameLower = name_1.toLowerCase();\n                if (lowerAttributes[nameLower])\n                    throw Error('Invalid request option: observing multiple case variations of the same attribute is not supported.');\n                attributes[name_1] = true;\n                lowerAttributes[nameLower] = true;\n            }\n            return Object.keys(attributes);\n        };\n        MutationSummaryOptionProcessor._elementFilterAttributes = function (selectors) {\n            var attributes = {};\n            selectors.forEach(function (selector) {\n                selector.qualifiers.forEach(function (qualifier) {\n                    attributes[qualifier.attrName] = true;\n                });\n            });\n            return Object.keys(attributes);\n        };\n        MutationSummaryOptionProcessor._validateAttribute = function (attribute) {\n            if (typeof attribute != 'string')\n                throw Error('Invalid request option. attribute must be a non-zero length string.');\n            attribute = attribute.trim();\n            if (!attribute)\n                throw Error('Invalid request option. attribute must be a non-zero length string.');\n            if (!attribute.match(MutationSummaryOptionProcessor._attributeFilterPattern))\n                throw Error('Invalid request option. invalid attribute name: ' + attribute);\n            return attribute;\n        };\n        MutationSummaryOptionProcessor._attributeFilterPattern = /^([a-zA-Z:_]+[a-zA-Z0-9_\\-:.]*)$/;\n        MutationSummaryOptionProcessor._optionKeys = {\n            'callback': true,\n            'queries': true,\n            'rootNode': true,\n            'oldPreviousSibling': true,\n            'observeOwnChanges': true\n        };\n        return MutationSummaryOptionProcessor;\n    }());\n\n    /**\n     * This is the main entry point class for the Mutation Summary library. When\n     * created, a MutationSummary takes care of the details of observing the DOM\n     * for changes, computing the \"net-effect\" of what's changed and then delivers\n     * these changes to the provided callback.\n     *\n     * @example\n     * ```\n     *\n     * const ms = new MutationSummary({\n     * callback(summaries: Summary[]) {\n     *    summaries.forEach((summary: Summary) => console.log(summary));\n     *  },\n     *  queries: [\n     *    { all: true }\n     *  ]\n     * });\n     * ```\n     */\n    var MutationSummary = /** @class */ (function () {\n        /**\n         * Creates a new MutationSummary class using the specified options.\n         *\n         * @param opts The options that configure how the MutationSummary\n         *             instance will observe and report changes.\n         */\n        function MutationSummary(opts) {\n            var _this = this;\n            this._connected = false;\n            this._options = MutationSummaryOptionProcessor.validateOptions(opts);\n            this._observerOptions = MutationSummaryOptionProcessor.createObserverOptions(this._options.queries);\n            this._root = this._options.rootNode;\n            this._callback = this._options.callback;\n            this._elementFilter = Array.prototype.concat.apply([], this._options.queries.map(function (query) {\n                return query.elementFilter ? query.elementFilter : [];\n            }));\n            if (!this._elementFilter.length)\n                this._elementFilter = undefined;\n            this._calcReordered = this._options.queries.some(function (query) {\n                return query.all;\n            });\n            this._queryValidators = []; // TODO(rafaelw): Shouldn't always define this.\n            if (MutationSummary.createQueryValidator) {\n                this._queryValidators = this._options.queries.map(function (query) {\n                    return MutationSummary.createQueryValidator(_this._root, query);\n                });\n            }\n            this._observer = new MutationObserver(function (mutations) {\n                _this._observerCallback(mutations);\n            });\n            this.reconnect();\n        }\n        /**\n         * Starts observation using an existing `MutationSummary` which has been\n         * disconnected. Note that this function is just a convenience method for\n         * creating a new `MutationSummary` with the same options. The next time\n         * changes are reported, they will relative to the state of the observed\n         * DOM at the point that `reconnect` was called.\n         */\n        MutationSummary.prototype.reconnect = function () {\n            if (this._connected)\n                throw Error('Already connected');\n            this._observer.observe(this._root, this._observerOptions);\n            this._connected = true;\n            this._checkpointQueryValidators();\n        };\n        /**\n         * Immediately calculates changes and returns them as an array of summaries.\n         * If there are no changes to report, returns undefined.\n         */\n        MutationSummary.prototype.takeSummaries = function () {\n            if (!this._connected)\n                throw Error('Not connected');\n            var summaries = this._createSummaries(this._observer.takeRecords());\n            return this._changesToReport(summaries) ? summaries : undefined;\n        };\n        /**\n         * Discontinues observation immediately. If DOM changes are pending delivery,\n         * they will be fetched and reported as the same array of summaries which\n         * are handed into the callback. If there is nothing to report,\n         * this function returns undefined.\n         *\n         * @returns A list of changes that have not yet been delivered to a callback.\n         */\n        MutationSummary.prototype.disconnect = function () {\n            var summaries = this.takeSummaries();\n            this._observer.disconnect();\n            this._connected = false;\n            return summaries;\n        };\n        MutationSummary.prototype._observerCallback = function (mutations) {\n            if (!this._options.observeOwnChanges)\n                this._observer.disconnect();\n            var summaries = this._createSummaries(mutations);\n            this._runQueryValidators(summaries);\n            if (this._options.observeOwnChanges)\n                this._checkpointQueryValidators();\n            if (this._changesToReport(summaries))\n                this._callback(summaries);\n            // disconnect() may have been called during the callback.\n            if (!this._options.observeOwnChanges && this._connected) {\n                this._checkpointQueryValidators();\n                this._observer.observe(this._root, this._observerOptions);\n            }\n        };\n        MutationSummary.prototype._createSummaries = function (mutations) {\n            if (!mutations || !mutations.length)\n                return [];\n            var projection = new MutationProjection(this._root, mutations, this._elementFilter, this._calcReordered, this._options.oldPreviousSibling);\n            var summaries = [];\n            for (var i = 0; i < this._options.queries.length; i++) {\n                summaries.push(new Summary(projection, this._options.queries[i]));\n            }\n            return summaries;\n        };\n        MutationSummary.prototype._checkpointQueryValidators = function () {\n            this._queryValidators.forEach(function (validator) {\n                if (validator)\n                    validator.recordPreviousState();\n            });\n        };\n        MutationSummary.prototype._runQueryValidators = function (summaries) {\n            this._queryValidators.forEach(function (validator, index) {\n                if (validator)\n                    validator.validate(summaries[index]);\n            });\n        };\n        MutationSummary.prototype._changesToReport = function (summaries) {\n            return summaries.some(function (summary) {\n                var summaryProps = ['added', 'removed', 'reordered', 'reparented',\n                    'valueChanged', 'characterDataChanged'];\n                if (summaryProps.some(function (prop) {\n                    return summary[prop] && summary[prop].length;\n                }))\n                    return true;\n                if (summary.attributeChanged) {\n                    var attrNames = Object.keys(summary.attributeChanged);\n                    var attrsChanged = attrNames.some(function (attrName) {\n                        return !!summary.attributeChanged[attrName].length;\n                    });\n                    if (attrsChanged)\n                        return true;\n                }\n                return false;\n            });\n        };\n        return MutationSummary;\n    }());\n\n    // Copyright 2013 Google Inc.\n    //\n    // Licensed under the Apache License, Version 2.0 (the \"License\");\n    // you may not use this file except in compliance with the License.\n    // You may obtain a copy of the License at\n    //\n    //     http://www.apache.org/licenses/LICENSE-2.0\n    //\n    // Unless required by applicable law or agreed to in writing, software\n    // distributed under the License is distributed on an \"AS IS\" BASIS,\n    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    // See the License for the specific language governing permissions and\n    // limitations under the License.\n    var TreeMirror = /** @class */ (function () {\n        function TreeMirror(root, delegate) {\n            this.root = root;\n            this.delegate = delegate;\n            this.idMap = {};\n        }\n        TreeMirror.prototype.initialize = function (rootId, children) {\n            this.idMap[rootId] = this.root;\n            for (var i = 0; i < children.length; i++)\n                this.deserializeNode(children[i], this.root);\n        };\n        TreeMirror.prototype.applyChanged = function (removed, addedOrMoved, attributes, text) {\n            var _this = this;\n            // NOTE: Applying the changes can result in an attempting to add a child\n            // to a parent which is presently an ancestor of the parent. This can occur\n            // based on random ordering of moves. The way we handle this is to first\n            // remove all changed nodes from their parents, then apply.\n            addedOrMoved.forEach(function (data) {\n                var node = _this.deserializeNode(data);\n                _this.deserializeNode(data.parentNode);\n                _this.deserializeNode(data.previousSibling);\n                if (node.parentNode)\n                    node.parentNode.removeChild(node);\n            });\n            removed.forEach(function (data) {\n                var node = _this.deserializeNode(data);\n                if (node.parentNode)\n                    node.parentNode.removeChild(node);\n            });\n            addedOrMoved.forEach(function (data) {\n                var node = _this.deserializeNode(data);\n                var parent = _this.deserializeNode(data.parentNode);\n                var previous = _this.deserializeNode(data.previousSibling);\n                parent.insertBefore(node, previous ? previous.nextSibling : parent.firstChild);\n            });\n            attributes.forEach(function (data) {\n                var node = _this.deserializeNode(data);\n                Object.keys(data.attributes).forEach(function (attrName) {\n                    var newVal = data.attributes[attrName];\n                    if (newVal === null) {\n                        node.removeAttribute(attrName);\n                    }\n                    else {\n                        if (!_this.delegate ||\n                            !_this.delegate.setAttribute ||\n                            !_this.delegate.setAttribute(node, attrName, newVal)) {\n                            node.setAttribute(attrName, newVal);\n                        }\n                    }\n                });\n            });\n            text.forEach(function (data) {\n                var node = _this.deserializeNode(data);\n                node.textContent = data.textContent;\n            });\n            removed.forEach(function (node) {\n                delete _this.idMap[node.id];\n            });\n        };\n        TreeMirror.prototype.deserializeNode = function (nodeData, parent) {\n            var _this = this;\n            if (nodeData === null)\n                return null;\n            var node = this.idMap[nodeData.id];\n            if (node)\n                return node;\n            var doc = this.root.ownerDocument;\n            if (doc === null)\n                doc = this.root;\n            switch (nodeData.nodeType) {\n                case Node.COMMENT_NODE:\n                    node = doc.createComment(nodeData.textContent);\n                    break;\n                case Node.TEXT_NODE:\n                    node = doc.createTextNode(nodeData.textContent);\n                    break;\n                case Node.DOCUMENT_TYPE_NODE:\n                    node = doc.implementation.createDocumentType(nodeData.name, nodeData.publicId, nodeData.systemId);\n                    break;\n                case Node.ELEMENT_NODE:\n                    if (this.delegate && this.delegate.createElement)\n                        node = this.delegate.createElement(nodeData.tagName);\n                    if (!node)\n                        node = doc.createElement(nodeData.tagName);\n                    Object.keys(nodeData.attributes).forEach(function (name) {\n                        if (!_this.delegate ||\n                            !_this.delegate.setAttribute ||\n                            !_this.delegate.setAttribute(node, name, nodeData.attributes[name])) {\n                            node.setAttribute(name, nodeData.attributes[name]);\n                        }\n                    });\n                    break;\n                default:\n                    throw \"Unsupported node type: \" + nodeData.nodeType;\n            }\n            this.idMap[nodeData.id] = node;\n            if (parent)\n                parent.appendChild(node);\n            if (nodeData.childNodes) {\n                for (var i = 0; i < nodeData.childNodes.length; i++)\n                    this.deserializeNode(nodeData.childNodes[i], node);\n            }\n            return node;\n        };\n        return TreeMirror;\n    }());\n\n    var TreeMirrorClient = /** @class */ (function () {\n        function TreeMirrorClient(target, mirror, testingQueries) {\n            var _this = this;\n            this.target = target;\n            this.mirror = mirror;\n            this.nextId = 1;\n            this.knownNodes = new NodeMap();\n            var rootId = this.serializeNode(target).id;\n            var children = [];\n            for (var child = target.firstChild; child; child = child.nextSibling)\n                children.push(this.serializeNode(child, true));\n            this.mirror.initialize(rootId, children);\n            var queries = [{ all: true }];\n            if (testingQueries)\n                queries = queries.concat(testingQueries);\n            this.mutationSummary = new MutationSummary({\n                rootNode: target,\n                callback: function (summaries) {\n                    _this.applyChanged(summaries);\n                },\n                queries: queries\n            });\n        }\n        TreeMirrorClient.prototype.disconnect = function () {\n            if (this.mutationSummary) {\n                this.mutationSummary.disconnect();\n                this.mutationSummary = undefined;\n            }\n        };\n        TreeMirrorClient.prototype.rememberNode = function (node) {\n            var id = this.nextId++;\n            this.knownNodes.set(node, id);\n            return id;\n        };\n        TreeMirrorClient.prototype.forgetNode = function (node) {\n            this.knownNodes.delete(node);\n        };\n        TreeMirrorClient.prototype.serializeNode = function (node, recursive) {\n            if (node === null)\n                return null;\n            var id = this.knownNodes.get(node);\n            if (id !== undefined) {\n                return { id: id };\n            }\n            var data = {\n                nodeType: node.nodeType,\n                id: this.rememberNode(node)\n            };\n            switch (data.nodeType) {\n                case Node.DOCUMENT_TYPE_NODE:\n                    var docType = node;\n                    data.name = docType.name;\n                    data.publicId = docType.publicId;\n                    data.systemId = docType.systemId;\n                    break;\n                case Node.COMMENT_NODE:\n                case Node.TEXT_NODE:\n                    data.textContent = node.textContent;\n                    break;\n                case Node.ELEMENT_NODE:\n                    var elm = node;\n                    data.tagName = elm.tagName;\n                    data.attributes = {};\n                    for (var i = 0; i < elm.attributes.length; i++) {\n                        var attr = elm.attributes[i];\n                        data.attributes[attr.name] = attr.value;\n                    }\n                    if (recursive && elm.childNodes.length) {\n                        data.childNodes = [];\n                        for (var child = elm.firstChild; child; child = child.nextSibling)\n                            data.childNodes.push(this.serializeNode(child, true));\n                    }\n                    break;\n            }\n            return data;\n        };\n        TreeMirrorClient.prototype.serializeAddedAndMoved = function (added, reparented, reordered) {\n            var _this = this;\n            var all = added.concat(reparented).concat(reordered);\n            var parentMap = new NodeMap();\n            all.forEach(function (node) {\n                var parent = node.parentNode;\n                var children = parentMap.get(parent);\n                if (!children) {\n                    children = new NodeMap();\n                    parentMap.set(parent, children);\n                }\n                children.set(node, true);\n            });\n            var moved = [];\n            parentMap.keys().forEach(function (parent) {\n                var children = parentMap.get(parent);\n                var keys = children.keys();\n                while (keys.length) {\n                    var node = keys[0];\n                    while (node.previousSibling && children.has(node.previousSibling))\n                        node = node.previousSibling;\n                    while (node && children.has(node)) {\n                        var data = _this.serializeNode(node);\n                        data.previousSibling = _this.serializeNode(node.previousSibling);\n                        data.parentNode = _this.serializeNode(node.parentNode);\n                        moved.push(data);\n                        children.delete(node);\n                        node = node.nextSibling;\n                    }\n                    keys = children.keys();\n                }\n            });\n            return moved;\n        };\n        TreeMirrorClient.prototype.serializeAttributeChanges = function (attributeChanged) {\n            var _this = this;\n            var map = new NodeMap();\n            Object.keys(attributeChanged).forEach(function (attrName) {\n                attributeChanged[attrName].forEach(function (element) {\n                    var record = map.get(element);\n                    if (!record) {\n                        record = _this.serializeNode(element);\n                        record.attributes = {};\n                        map.set(element, record);\n                    }\n                    record.attributes[attrName] = element.getAttribute(attrName);\n                });\n            });\n            return map.keys().map(function (node) {\n                return map.get(node);\n            });\n        };\n        TreeMirrorClient.prototype.applyChanged = function (summaries) {\n            var _this = this;\n            var summary = summaries[0];\n            var removed = summary.removed.map(function (node) {\n                return _this.serializeNode(node);\n            });\n            var moved = this.serializeAddedAndMoved(summary.added, summary.reparented, summary.reordered);\n            var attributes = this.serializeAttributeChanges(summary.attributeChanged);\n            var text = summary.characterDataChanged.map(function (node) {\n                var data = _this.serializeNode(node);\n                data.textContent = node.textContent;\n                return data;\n            });\n            this.mirror.applyChanged(removed, moved, attributes, text);\n            summary.removed.forEach(function (node) {\n                _this.forgetNode(node);\n            });\n        };\n        return TreeMirrorClient;\n    }());\n\n    // Copyright 2011 Google Inc.\n    //\n    // Licensed under the Apache License, Version 2.0 (the \"License\");\n    // you may not use this file except in compliance with the License.\n    // You may obtain a copy of the License at\n    //\n    //     http://www.apache.org/licenses/LICENSE-2.0\n    //\n    // Unless required by applicable law or agreed to in writing, software\n    // distributed under the License is distributed on an \"AS IS\" BASIS,\n    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    // See the License for the specific language governing permissions and\n    // limitations under the License.\n    // @ts-ignore\n    // @ts-ignore\n    if (MutationObserver === undefined) {\n        console.error('DOM Mutation Observers are required.');\n        console.error('https://developer.mozilla.org/en-US/docs/DOM/MutationObserver');\n        throw Error('DOM Mutation Observers are required');\n    }\n\n    exports.ChildListChange = ChildListChange;\n    exports.MutationProjection = MutationProjection;\n    exports.MutationSummary = MutationSummary;\n    exports.NodeChange = NodeChange;\n    exports.NodeMap = NodeMap;\n    exports.Qualifier = Qualifier;\n    exports.Selector = Selector;\n    exports.Summary = Summary;\n    exports.TreeChanges = TreeChanges;\n    exports.TreeMirror = TreeMirror;\n    exports.TreeMirrorClient = TreeMirrorClient;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=mutation-summary.js.map\n","import { getEmote, containsEmote } from \"./emotes.js\";\r\nimport { urlChangeHandler } from \"./navigation.js\";\r\nimport { MutationSummary } from \"mutation-summary\";\r\n\r\n// Helper functions\r\nconst createTextFragment = (text) => {\r\n  const span = document.createElement(\"span\");\r\n  span.classList.add(\"text-fragment\");\r\n  if (text.trim() === \"\") span.classList.add(\"spacer\");\r\n  span.textContent = text;\r\n  return span;\r\n};\r\n\r\nconst createEmoteImage = (emote) => {\r\n  const img = document.createElement(\"img\");\r\n  img.src = emote.url;\r\n  img.alt = emote.name;\r\n  img.classList.add(\"simple-emote-extension\");\r\n  if (emote.modifier) img.classList.add(\"modifier\");\r\n  return img;\r\n};\r\n\r\nconst processWord = (word, fragment, text, modifierDiv, currentState) => {\r\n  if (word.startsWith(\"@\"))\r\n    return { fragment, text, modifierDiv, currentState }; // Skip mentions\r\n  const emote = getEmote(word);\r\n  if (emote) {\r\n    if (text.trim()) {\r\n      fragment.appendChild(createTextFragment(text));\r\n      text = \"\";\r\n    }\r\n\r\n    const emoteImage = createEmoteImage(emote);\r\n    if (emote.modifier) {\r\n      if (currentState === \"PROCESSING\") {\r\n        currentState = \"PROCESSING_MODIFIER\";\r\n        modifierDiv = document.createElement(\"div\");\r\n        modifierDiv.classList.add(\"modifier-container\");\r\n        if (fragment.lastElementChild instanceof HTMLImageElement) {\r\n          modifierDiv.appendChild(fragment.lastElementChild);\r\n        }\r\n      }\r\n      modifierDiv.appendChild(emoteImage);\r\n    } else {\r\n      if (currentState === \"PROCESSING_MODIFIER\") {\r\n        fragment.appendChild(modifierDiv);\r\n        modifierDiv = null;\r\n        currentState = \"PROCESSING\";\r\n      }\r\n      fragment.appendChild(emoteImage);\r\n    }\r\n  } else {\r\n    text += ` ${word} `;\r\n  }\r\n\r\n  return { fragment, text, modifierDiv, currentState };\r\n};\r\n\r\nconst processMessageContent = (chatMessageBody) => {\r\n  let currentState = \"PROCESSING\";\r\n  let fragment = new DocumentFragment();\r\n  let text = \"\";\r\n  let modifierDiv = null;\r\n\r\n  let textFragmentSpan = chatMessageBody.querySelector(\".text-fragment\");\r\n  if (textFragmentSpan) {\r\n    const words = textFragmentSpan.textContent.split(/\\s+/);\r\n    words.forEach((word) => {\r\n      ({ fragment, text, modifierDiv, currentState } = processWord(\r\n        word,\r\n        fragment,\r\n        text,\r\n        modifierDiv,\r\n        currentState\r\n      ));\r\n    });\r\n  }\r\n\r\n  return { fragment, text, modifierDiv, currentState };\r\n};\r\n\r\nconst processChatMessage = (chatMessageBody) => {\r\n  if (!chatMessageBody || !containsEmote(chatMessageBody)) return;\r\n\r\n  let { fragment, text, modifierDiv } = processMessageContent(chatMessageBody);\r\n  if (text.trim()) fragment.appendChild(createTextFragment(text));\r\n  if (modifierDiv) fragment.appendChild(modifierDiv);\r\n\r\n  chatMessageBody.replaceChildren(fragment);\r\n};\r\n\r\nconst setupChatObserver = () => {\r\n  let eventListenersLoaded = false;\r\n\r\n  const processMutations = async (summaries) => {\r\n    const chatMessages = summaries[0].added; // Array of added chat messages\r\n    const promises = [];\r\n\r\n    chatMessages.forEach((node) => {\r\n      if (!eventListenersLoaded) {\r\n        manageEventListeners();\r\n        eventListenersLoaded = true;\r\n      }\r\n\r\n      if (node.dataset?.aTarget === \"chat-line-message-body\") {\r\n        promises.push(processChatMessage(node));\r\n      }\r\n\r\n      if (node.classList.contains(\"tw-title\")) {\r\n        console.log(node.parentElement.href);\r\n      }\r\n    });\r\n\r\n    await Promise.all(promises);\r\n  };\r\n\r\n  const startObserving = () => {\r\n    const targetNode = document.querySelector(\r\n      \".channel-root__right-column.channel-root__right-column--expanded\"\r\n    );\r\n\r\n    if (targetNode) {\r\n      // Use mutation-summary to watch for added chat messages\r\n      const ms = new MutationSummary({\r\n        callback: processMutations, // Callback to handle mutations\r\n        queries: [\r\n          { element: `[data-a-target=\"chat-line-message-body\"]` },\r\n          { element: \"h1.tw-title\" },\r\n        ], // Only track added chat lines and the parent of the username\r\n      });\r\n\r\n      console.log(\"Observer started on target node.\");\r\n\r\n      // Process mutations\r\n      function processMutations(summaries) {\r\n        const addedChatLines = summaries[0].added;\r\n        const addedStreamInfo = summaries[1].added;\r\n\r\n        addedChatLines.forEach((chatLine) => {\r\n          // Process chat lines here\r\n          processChatMessage(chatLine);\r\n        });\r\n\r\n        addedStreamInfo.forEach((titleElement) => {\r\n          // Call the function to find and process the title element\r\n          if (\r\n            titleElement &&\r\n            titleElement.parentElement &&\r\n            titleElement.parentElement.href\r\n          ) {\r\n            urlChangeHandler(titleElement.parentElement.href.split(\"/\").pop());\r\n          }\r\n        });\r\n      }\r\n    } else {\r\n      console.log(\"Target node not found, checking again in 1000ms...\");\r\n    }\r\n  };\r\n\r\n  const intervalId = setInterval(() => {\r\n    const targetNode = document.querySelector(\r\n      \".channel-root__right-column.channel-root__right-column--expanded\"\r\n    );\r\n\r\n    if (targetNode) {\r\n      clearInterval(intervalId); // Stop checking once the target node is found\r\n      startObserving(); // Start observing the target node\r\n    }\r\n  }, 1000); // Check every 1 second\r\n};\r\n\r\nconst addModifierStyles = async () => {\r\n  const style = document.createElement(\"style\");\r\n  style.textContent = `\r\n      .modifier-container {\r\n        display: unset; /* Remove inherited display properties */\r\n        display: inline-grid; /* Use grid for stacking */\r\n        justify-items: center; /* Center items horizontally */\r\n      }\r\n\r\n      .chat-line__no-background * {\r\n        align-items: center;\r\n        vertical-align: middle;\r\n      }\r\n\r\n      .modifier {\r\n        z-index: 1;\r\n      }\r\n\r\n      .modifier-container img {\r\n        grid-area: 1 / 1; /* Stack all images in the same grid area */\r\n        width: min-content; /* Make images fill the container width */\r\n        height: min-content; /* Maintain aspect ratio */\r\n      }\r\n      \r\n      \r\n      .emote-tooltip {\r\n        position: absolute;\r\n        background-color: rgba(0, 0, 0, 0.5); /* 50% transparent black */\r\n        color: white;\r\n        padding: 5px; /* Add some padding around the tooltip */\r\n        border-radius: 4px;\r\n        font-size: 12px;\r\n        pointer-events: none; /* Make sure the tooltip doesn't interfere with mouse events */\r\n        z-index: 1000;\r\n        text-align: center; /* Center the text */\r\n      }\r\n\r\n      .emote-preview img {\r\n        padding: 5px; /* Add padding around the image */\r\n      }\r\n\r\n      .emote-info {\r\n        margin-top: 5px;\r\n      }\r\n\r\n      .emote-name, .emote-service {\r\n        display: block;\r\n        font-size: 16px;\r\n      }\r\n\r\n      .emote-service {\r\n        font-size: 13px;\r\n        color: #ccc; /* Light gray for the service name */\r\n      }`;\r\n\r\n  // Append the style element to the document head\r\n  document.head.appendChild(style);\r\n};\r\n\r\nconst manageEventListeners = () => {\r\n  const root = document.querySelector(\".root\");\r\n\r\n  let tooltip = null;\r\n  let isTooltipActive = false;\r\n\r\n  root.addEventListener(\"mouseover\", (event) => {\r\n    const emoteElement = event.target.closest(\".simple-emote-extension\");\r\n    if (!emoteElement) return;\r\n\r\n    const modifierContainer = emoteElement.closest(\".modifier-container\");\r\n    const emotes = modifierContainer\r\n      ? Array.from(\r\n          modifierContainer.querySelectorAll(\".simple-emote-extension\")\r\n        )\r\n      : [emoteElement];\r\n\r\n    // If a tooltip already exists, remove it before creating a new one\r\n    if (tooltip) {\r\n      tooltip.remove();\r\n      tooltip = null;\r\n    }\r\n\r\n    tooltip = document.createElement(\"div\");\r\n    tooltip.classList.add(\"emote-tooltip\");\r\n    document.body.appendChild(tooltip);\r\n\r\n    emotes.forEach((emote) => {\r\n      const emoteInfo = getEmote(emote.getAttribute(\"alt\"));\r\n      const emoteContent = document.createElement(\"div\");\r\n      emoteContent.classList.add(\"emote-content\");\r\n\r\n      const emotePreview = document.createElement(\"div\");\r\n      emotePreview.classList.add(\"emote-preview\");\r\n      const emoteImg = document.createElement(\"img\");\r\n      emoteImg.src = emoteInfo.bigUrl;\r\n      emoteImg.alt = emoteInfo.name;\r\n      emotePreview.appendChild(emoteImg);\r\n\r\n      const emoteInfoDiv = document.createElement(\"div\");\r\n      emoteInfoDiv.classList.add(\"emote-info\");\r\n      const emoteNameDiv = document.createElement(\"div\");\r\n      emoteNameDiv.classList.add(\"emote-name\");\r\n      emoteNameDiv.textContent = emoteInfo.name;\r\n\r\n      const emoteServiceDiv = document.createElement(\"div\");\r\n      emoteServiceDiv.classList.add(\"emote-service\");\r\n      emoteServiceDiv.textContent = emoteInfo.service.toUpperCase(); // Assuming service is part of emote object\r\n\r\n      emoteInfoDiv.appendChild(emoteNameDiv);\r\n      emoteInfoDiv.appendChild(emoteServiceDiv);\r\n      emoteContent.appendChild(emotePreview);\r\n      emoteContent.appendChild(emoteInfoDiv);\r\n\r\n      tooltip.appendChild(emoteContent);\r\n    });\r\n\r\n    const updateTooltipPosition = (e) => {\r\n      const tooltipRect = tooltip.getBoundingClientRect();\r\n      tooltip.style.left = `${Math.min(\r\n        window.innerWidth - tooltipRect.width - 10,\r\n        e.clientX\r\n      )}px`;\r\n      tooltip.style.top = `${Math.min(\r\n        window.innerHeight - tooltipRect.height,\r\n        e.clientY\r\n      )}px`;\r\n    };\r\n\r\n    updateTooltipPosition(event);\r\n    isTooltipActive = true;\r\n\r\n    document.addEventListener(\"mousemove\", updateTooltipPosition);\r\n\r\n    // Tooltip removal logic\r\n    const removeTooltip = () => {\r\n      if (tooltip) {\r\n        tooltip.remove();\r\n        tooltip = null;\r\n      }\r\n      document.removeEventListener(\"mousemove\", updateTooltipPosition);\r\n      isTooltipActive = false;\r\n    };\r\n\r\n    const handleMouseLeave = () => {\r\n      // Ensure tooltip is removed when mouse leaves the emote area\r\n      removeTooltip();\r\n    };\r\n\r\n    emoteElement.addEventListener(\"mouseleave\", handleMouseLeave, {\r\n      once: true,\r\n    });\r\n\r\n    document.addEventListener(\r\n      \"mousemove\",\r\n      (e) => {\r\n        if (!isTooltipActive) return;\r\n        // Check if the mouse has moved significantly far from the emote\r\n        const distanceX = Math.abs(\r\n          e.clientX - emoteElement.getBoundingClientRect().left\r\n        );\r\n        const distanceY = Math.abs(\r\n          e.clientY - emoteElement.getBoundingClientRect().top\r\n        );\r\n        const maxDistance = 100; // Adjust this threshold as needed\r\n\r\n        if (distanceX > maxDistance || distanceY > maxDistance) {\r\n          handleMouseLeave();\r\n        }\r\n      },\r\n      { once: true }\r\n    );\r\n  });\r\n};\r\n\r\nexport {\r\n  setupChatObserver,\r\n  processChatMessage,\r\n  manageEventListeners,\r\n  addModifierStyles,\r\n};\r\n","const emotes = new Map();\r\nlet emotesDebug = true;\r\nlet emoteRegex;\r\nlet globalEmotesLoaded = false;\r\nlet currentUserObject;\r\n\r\nconst loadTwitchEmotes = async (username) => {\r\n  if (!username) return null;\r\n\r\n  const query = `query{user(login:\"${username}\"){subscriptionProducts{emotes{id state text token}}}}`;\r\n\r\n  try {\r\n    const response = await fetch(\"https://gql.twitch.tv/gql\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Client-Id\": \"ue6666qo983tsx6so1t0vnawi233wa\",\r\n      },\r\n      body: JSON.stringify({ query }),\r\n    });\r\n\r\n    const data = await response.json();\r\n\r\n    if (data.errors) {\r\n      const errorMessage = data.errors[0].message;\r\n      throw new Error(`Twitch API request failed: ${errorMessage}`);\r\n    }\r\n\r\n    data.data.user.subscriptionProducts.forEach((product) => {\r\n      product.emotes.forEach((emote) => {\r\n        emotes.set(emote.token, {\r\n          url: `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/2.0`,\r\n        });\r\n      });\r\n    });\r\n\r\n    return emotes;\r\n  } catch (error) {\r\n    console.error(\"Error fetching emotes:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nconst loadGlobalTwitchEmotes = async (emoteSetId) => {\r\n  if (!emoteSetId) return null;\r\n\r\n  const query = `\r\n    query {\r\n      emoteSet(id: \"${emoteSetId}\") { \r\n        emotes { id token }\r\n      }\r\n    }\r\n  `;\r\n\r\n  try {\r\n    const response = await fetch(\"https://gql.twitch.tv/gql\", {\r\n      method: \"POST\",\r\n      headers: {\r\n        \"Client-Id\": \"ue6666qo983tsx6so1t0vnawi233wa\",\r\n      },\r\n      body: JSON.stringify({ query }),\r\n    });\r\n\r\n    const data = await response.json();\r\n\r\n    if (data.errors) {\r\n      const errorMessage = data.errors[0].message;\r\n      throw new Error(`Twitch API request failed: ${errorMessage}`);\r\n    }\r\n    if (data && data.data && data.data.emoteSet && data.data.emoteSet.emotes) {\r\n      data.data.emoteSet.emotes.forEach((emote) => {\r\n        emotes.set(emote.token, {\r\n          url: `https://static-cdn.jtvnw.net/emoticons/v2/${emote.id}/default/dark/2.0`,\r\n        });\r\n      });\r\n    }\r\n  } catch (error) {\r\n    console.error(\"Error fetching emotes:\", error);\r\n    throw error;\r\n  }\r\n};\r\n\r\nasync function loadFFZEmotes(id) {\r\n  try {\r\n    const response = await fetch(\r\n      `https://api.frankerfacez.com/v1/room/id/${id}`\r\n    );\r\n    if (!response.ok) {\r\n      throw new Error(`FFZ HTTP error! status: ${response.status}`);\r\n    }\r\n    const data = await response.json();\r\n    if (data && data.sets && data.room && data.room.set) {\r\n      for (const emote of data.sets[data.room.set].emoticons) {\r\n        if (emote.name && emote.urls && emote.urls[1]) {\r\n          emotes.set(emote.name, {\r\n            name: emote.name,\r\n            url: emote.urls[1],\r\n            bigUrl: emote.urls[4],\r\n            height: emote.height || null,\r\n            width: emote.width || null,\r\n            service: \"ffz\"\r\n          });\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    if (emotesDebug) {\r\n      console.error(`Error loading FFZ emotes for ${username}:`, error.message);\r\n    }\r\n  }\r\n}\r\n\r\nasync function loadBTTVEmotes(userId) {\r\n  try {\r\n    const response = await fetch(\r\n      `https://api.betterttv.net/3/cached/users/twitch/${userId}`\r\n    );\r\n    if (!response.ok) {\r\n      throw new Error(`BTTV HTTP error! status: ${response.status}`);\r\n    }\r\n    const data = await response.json();\r\n    const allEmotes = [\r\n      ...(data.channelEmotes || []),\r\n      ...(data.sharedEmotes || []),\r\n    ];\r\n    for (const emote of allEmotes) {\r\n      if (emote.code && emote.id) {\r\n        emotes.set(emote.code, {\r\n          name: emote.code,\r\n          url: `https://cdn.betterttv.net/emote/${emote.id}/1x`,\r\n          bigUrl: `https://cdn.betterttv.net/emote/${emote.id}/3x`,\r\n          width: emote.width || null,\r\n          height: emote.height || null,\r\n          service: \"bttv\"\r\n        });\r\n      }\r\n    }\r\n  } catch (error) {\r\n    if (emotesDebug) {\r\n      console.error(\r\n        `Error loading BTTV emotes for user ${userId}:`,\r\n        error.message\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nasync function load7TVEmotes(userId) {\r\n  try {\r\n    const response = await fetch(`https://7tv.io/v3/users/twitch/${userId}`);\r\n    if (!response.ok) {\r\n      throw new Error(`7TV HTTP error! status: ${response.status}`);\r\n    }\r\n    const data = await response.json();\r\n    if (data && data.emote_set && data.emote_set.emotes) {\r\n      for (const emote of data.emote_set.emotes) {\r\n        const file = emote.data?.host?.files.find((f) => f.name === \"1x.webp\");\r\n        if (emote.name && emote.id && file) {\r\n          emotes.set(emote.name, {\r\n            name: emote.name,\r\n            url: `https:${emote.data.host.url}/1x.webp`,\r\n            bigUrl: `https:${emote.data.host.url}/3x.webp`,\r\n            width: file.width || null,\r\n            height: file.height || null,\r\n            modifier: emote.flags > 0,\r\n            service: \"7tv\"\r\n          });\r\n        }\r\n      }\r\n    }\r\n  } catch (error) {\r\n    if (emotesDebug) {\r\n      console.error(\r\n        `Error loading 7TV emotes for user ${userId}:`,\r\n        error.message\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nasync function loadGlobalEmotes() {\r\n  try {\r\n    const [ffzResponse, bttvResponse, sevenTVResponse] = await Promise.all([\r\n      fetch(\"https://api.frankerfacez.com/v1/set/global/ids\"),\r\n      fetch(\"https://api.betterttv.net/3/cached/emotes/global\"),\r\n      fetch(\"https://7tv.io/v3/emote-sets/global\"),\r\n    ]);\r\n\r\n    if (!ffzResponse.ok)\r\n      throw new Error(`FFZ Global HTTP error! status: ${ffzResponse.status}`);\r\n    if (!bttvResponse.ok)\r\n      throw new Error(`BTTV Global HTTP error! status: ${bttvResponse.status}`);\r\n    if (!sevenTVResponse.ok)\r\n      throw new Error(\r\n        `7TV Global HTTP error! status: ${sevenTVResponse.status}`\r\n      );\r\n\r\n    const [ffzGlobal, bttvGlobal, sevenTVGlobal] = await Promise.all([\r\n      ffzResponse.json(),\r\n      bttvResponse.json(),\r\n      sevenTVResponse.json(),\r\n    ]);\r\n\r\n    // Populate FFZ global emotes\r\n    if (ffzGlobal && ffzGlobal.sets && ffzGlobal.sets[3]) {\r\n      for (const emote of ffzGlobal.sets[3].emoticons) {\r\n        if (emote.name && emote.urls && emote.urls[1]) {\r\n          emotes.set(emote.name, {\r\n            name: emote.name,\r\n            url: emote.urls[1],\r\n            bigUrl: emote.urls[4],\r\n            height: emote.height || null,\r\n            width: emote.width || null,\r\n            service: \"ffz\"\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Populate BTTV global emotes\r\n    if (bttvGlobal) {\r\n      for (const emote of bttvGlobal) {\r\n        if (emote.code && emote.id) {\r\n          emotes.set(emote.code, {\r\n            name: emote.code,\r\n            url: `https://cdn.betterttv.net/emote/${emote.id}/1x`,\r\n            bigUrl: `https://cdn.betterttv.net/emote/${emote.id}/3x`,\r\n            width: emote.width || null,\r\n            height: emote.height || null,\r\n            service: \"bttv\"\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Populate 7TV global emotes\r\n    if (sevenTVGlobal && sevenTVGlobal.emotes) {\r\n      for (const emote of sevenTVGlobal.emotes) {\r\n        const file = emote.data?.host?.files.find((f) => f.name === \"1x.webp\");\r\n        if (emote.name && emote.id && file) {\r\n          emotes.set(emote.name, {\r\n            name: emote.name,\r\n            url: `https:${emote.data.host.url}/1x.webp`,\r\n            bigUrl: `https:${emote.data.host.url}/3x.webp`,\r\n            width: file.width || null,\r\n            height: file.height || null,\r\n            modifier: emote.flags > 0,\r\n            service: \"7tv\"\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    if (emotesDebug) {\r\n      console.info(\"Loaded global emotes:\", emotes.size);\r\n    }\r\n  } catch (error) {\r\n    if (emotesDebug) {\r\n      console.error(\"Error loading global emotes:\", error.message);\r\n    }\r\n  }\r\n}\r\n\r\nasync function loadEmotes(userObject) {\r\n  // Check if all required fields are present\r\n  if (!userObject || !userObject.username || !userObject.id) {\r\n    if (emotesDebug) {\r\n      console.error(\"Invalid userObject provided:\", userObject);\r\n    }\r\n    return;\r\n  }\r\n\r\n  // Check if emotes are already loaded for this user\r\n  if (currentUserObject && currentUserObject.id === userObject.id) {\r\n    if (emotesDebug) {\r\n      console.info(`Emotes already loaded for ${userObject.username}`);\r\n    }\r\n    return; \r\n  }\r\n\r\n  // Update currentUserObject to the new user\r\n  currentUserObject = userObject; \r\n\r\n  if (emotesDebug) {\r\n    console.info(`Loading emotes for channel: ${userObject.username}`);\r\n  }\r\n\r\n  try {\r\n    await Promise.all([\r\n      loadFFZEmotes(userObject.id),\r\n      loadBTTVEmotes(userObject.id),\r\n      load7TVEmotes(userObject.id),\r\n    ]);\r\n\r\n    emoteRegex = createEmoteRegex(emotes);\r\n\r\n    if (emotesDebug) {\r\n      console.info(`Loaded ${emotes.size} channel emotes`);\r\n    }\r\n  } catch (error) {\r\n    if (emotesDebug) {\r\n      console.error(\"Failed to load channel emotes:\", error);\r\n    }\r\n  }\r\n}\r\n\r\nfunction getEmote(emoteName) {\r\n  return emotes.get(emoteName);\r\n}\r\n\r\nconst createEmoteRegex = (emoteMap) => {\r\n  const escapedEmoteNames = Array.from(emoteMap.keys()).map((name) => {\r\n    // Escape all special regex characters, including the colon\r\n    return name.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&'); \r\n  });\r\n\r\n  // Use a more flexible pattern to match emotes\r\n  return new RegExp(\r\n    escapedEmoteNames.map((name) => `(${name})`).join(\"|\"), \r\n    \"i\"\r\n  );\r\n};\r\n\r\nconst containsEmote = (element) => emoteRegex.test(element.textContent);\r\n\r\nasync function initializeEmotes() {\r\n  // Load global emotes once\r\n  if (!globalEmotesLoaded)  {\r\n    await loadGlobalEmotes();\r\n    globalEmotesLoaded = true;\r\n  }\r\n  \r\n  emoteRegex = createEmoteRegex(emotes);\r\n}\r\n\r\n// Export necessary functions and the debug variable\r\nexport { loadEmotes, getEmote, initializeEmotes, containsEmote };\r\n","function getAuthTokenCookie() {\r\n  const cookies = document.cookie.split(\";\");\r\n  for (let i = 0; i < cookies.length; i++) {\r\n    const cookie = cookies[i].trim();\r\n    // Does this cookie string begin with the name we want?\r\n    if (cookie.startsWith(\"auth-token=\")) {\r\n      return cookie.substring(\"auth-token=\".length, cookie.length);\r\n    }\r\n  }\r\n  return null; // Cookie not found\r\n}\r\n\r\n// Fetch Twitch user ID by username\r\nconst getTwitchUserId = async (username) => {\r\n  if (!username) return null;\r\n\r\n  const response = await fetch(\"https://gql.twitch.tv/gql\", {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Client-Id\": \"ue6666qo983tsx6so1t0vnawi233wa\",\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      query: `{user(login:\"${username}\" lookupType:ALL){id}}`,\r\n    }),\r\n  });\r\n\r\n  if (!response.ok) return null;\r\n\r\n  const data = await response.json();\r\n\r\n  return data?.data?.user?.id\r\n    ? { id: data.data.user.id, username: username }\r\n    : null;\r\n};\r\n\r\n// Listen for navigation changes to detect new usernames\r\n\r\n\r\nexport {\r\n  getTwitchUserId,\r\n  getAuthTokenCookie,\r\n};\r\n","import { getTwitchUserId } from \"./lib.js\";\r\nimport { initializeEmotes, loadEmotes } from \"./emotes.js\";\r\n\r\n// Keep track of the current username\r\n\r\nlet currentUsername = null;\r\n\r\n// Log website navigation\r\n\r\nlet navDebug = true;\r\n\r\n\r\n// Ignored pages for URL changes\r\n\r\nconst ignoredPages = {\r\n  settings: true,\r\n  payments: true,\r\n  inventory: true,\r\n  messages: true,\r\n  subscriptions: true,\r\n  friends: true,\r\n  directory: true,\r\n  videos: true,\r\n  prime: true,\r\n  downloads: true,\r\n};\r\n\r\nfunction matchChannelName(url) {\r\n  if (!url) return undefined;\r\n\r\n  const match = url.match(\r\n    /^https?:\\/\\/(?:www\\.)?twitch\\.tv\\/(\\w+)\\/?(?:\\?.*)?$/\r\n  );\r\n\r\n  if (match && !ignoredPages[match[1]]) {\r\n    return match[1];\r\n  }\r\n\r\n  return undefined;\r\n}\r\n\r\n// if (window.navigation) {\r\n//   window.navigation.addEventListener(\"navigate\", async (event) => {\r\n//     const newUsername = matchChannelName(event.destination.url);\r\n\r\n//     if (newUsername) {\r\n//       await urlChangeHandler(newUsername);\r\n//     }\r\n//   });\r\n// }\r\n\r\nconst urlChangeHandler = async (newUsername) => {\r\n  // Check if the username has actually changed\r\n\r\n  if (newUsername !== currentUsername) {\r\n    if (navDebug) {\r\n      console.info(\"URL changed, loading emotes for new user:\", newUsername);\r\n    }\r\n\r\n    currentUsername = newUsername; // Update the current username\r\n\r\n    const data = await getTwitchUserId(newUsername);\r\n    await initializeEmotes();\r\n    await loadEmotes({ id: data.id, username: data.username });\r\n  } else {\r\n    if (navDebug) {\r\n      console.info(\"URL did not change, skipping emote loading.\");\r\n    }\r\n  }\r\n};\r\n\r\nexport { matchChannelName, urlChangeHandler };\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { getTwitchUserId } from \"./lib.js\";\r\n\r\nimport { loadEmotes, initializeEmotes } from \"./emotes.js\";\r\n\r\nimport {\r\n  setupChatObserver,\r\n  addModifierStyles,\r\n  manageEventListeners,\r\n} from \"./dom2.js\";\r\n\r\nimport { matchChannelName } from \"./navigation.js\";\r\n\r\n\r\nsetupChatObserver();\r\n\r\nasync function main() {\r\n  await addModifierStyles();\r\n  await initializeEmotes();\r\n  manageEventListeners();\r\n  const currentUsername = matchChannelName(window.location.href);\r\n\r\n  if (currentUsername) {\r\n    const data = await getTwitchUserId(currentUsername);\r\n    await loadEmotes({ id: data.id, username: data.username });\r\n  }\r\n}\r\n\r\nmain().catch(console.error);\r\n"],"names":[],"sourceRoot":""}